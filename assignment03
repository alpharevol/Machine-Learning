import numpy as np
import matplotlib.pyplot as plt

def inputData():
    point_x = np.random.randint(-100, 100, 300)
    point_y = np.random.randint(-100, 100, 300)

    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)
    ax.spines['bottom'].set_position(('data', 0))
    ax.spines['left'].set_position(('data', 0))
    plt.title('random 300 points')
    plt.scatter(point_x, point_y, color='b')
    plt.show()

    return [point_x, point_y]
    
    
    def initalLabel(numCluster):
    label_list = np.random.randint(1,numCluster+1,300)

    return label_list
    
    def initCluster(cluster_num, label_list, point_x, point_y):
    first_cluster = []

    for cluster in range(1, cluster_num + 1):
        cluster_x = []
        cluster_y = []
        for label_index in range(len(label_list)):
            if cluster == label_list[label_index]:
                cluster_x.append(point_x[label_index])
                cluster_y.append(point_y[label_index])
        first_cluster.append([cluster_x, cluster_y])

    center = calculateCenter(cluster_num, first_cluster)

    plot(cluster_num, first_cluster, center)

    return first_cluster, center
    
    def calculateCenter(cluster_num, clusterResult):
    clusterCenter = []
    for cluster in range(cluster_num):
        x = clusterResult[cluster][0]
        y = clusterResult[cluster][1]
        try:
            clusterCenter.append([(sum(x)/len(x)), (sum(y)/len(y))])
        except ZeroDivisionError:
            x = np.random.randint(-100,100,1)
            y = np.random.randint(-100,100,1)
            clusterCenter.append([x[0],y[0]])
    return clusterCenter
    
    
    
    def distance(x_1, y_1, x_2, y_2):
    return pow((x_1-x_2), 2) + pow((y_1-y_2), 2)
    
    
    def energy(cluster, center):
    energy_num = []
    for i in range(len(cluster)):
        for j in range(len(cluster[i][0])):
            k = distance(cluster[i][0][j], cluster[i][1][j], center[i][0], center[i][1])
            energy_num.append(k)
    return sum(energy_num) / len(energy_num)
    
    
    
    
